# OpenGLの仕様を読んでいる道なかば

この記事は[進捗 Advent Calendar 2020](https://github.com/t-sin/shinchoku-advent-calendar-2020)の21日目の記事です。

## 概要

[16日目の記事](2020-12-16.md)でOpenGL勉強中であることを書きました。ゲームのグラフィックのため、というのもそうなのですが、ジェネレーティブ・アート的なことをするのにもインタラクティブなメディアアートをするのにも役立ちそうというか基礎というか教養な側面があるような気がするので、覚えたいというのが動機です。

ここでは、OpenGL 4.6の仕様書を途中まで読んでいていまの時点でわかっていることを軽く書きます。書きかけのOpenGL入門メモ、というような風情のものだと思ってください。

## 現状

読んでいる仕様書は以下のものです。

- [OpenGL 4.6 Core Profile Specification](https://www.khronos.org/registry/OpenGL/specs/gl/glspec46.core.pdf)

7章「プログラムとシェーダ」の冒頭あたり、ページでいうと89ページ (PDFのページ数で111ページ) まで読みました。全体で800ページを超える仕様書なのでまだ1/10なのですね…。

## OpenGL超入門！

というわけで読んだところから得られた情報を書きます。超訳OpenGLのような趣向で、以下の構成でいきます。

1. イントロダクション
2. OpenGL基礎
3. データフローモデル

### イントロダクション

OpenGLとは、グラフィック描画のための機能を提供するデータとAPIの集合です。またGPUの操作を抽象化した規格という側面もあります。グラフィック描画のための計算過程をいくつかの段階がデータを入力から出力に流していく過程とし、それぞれの段階の機能と扱えるデータを規定しています。OpenGLはいまではグラフィック描画のみではなくGPUで汎用の計算を行うための仕組みも提供しています。

OpenGLをちゃんと利用しようと思うとCore Profileだけでは完結しません。たとえばシェーダのプログラムを記述する言語は別に仕様書が切られています。シェーダとは！ OpenGLの計算過程をパイプラインといいますが、パイプラインの各段階 (ステージ) は固定機能のものとプログラマブルなものがありますが、プログラマブルなステージで動かすプログラムのことです。またそのシェーダプログラムのバイナリ表現SPIR-Vの規格もあります。

### OpenGL基礎

OpenGLの実行モデルは、サーバ (GPU) とクライアント (アプリケーション) がコンテキストを通じてデータをやりとりし操作を依頼する感じになっています。クライアントはコンテキストの中にある状態 (ステート) を通じてデータを送ったりサーバの状態を知ったりするのですが、プログラマはGPUにデータを送るとき、オブジェクトの名前を確保し、コンテキストステートに設定し、ステートにデータを送り、使わなければ名前を開放し、といった手順を実施します。ぼくにはこの手順が無駄に面倒だと思っていましたが、これはどうもヘテロジニアスな環境でメモリも分かれているようなシステム (つまりCPUとGPU) を想定した手順だからというのが理由のようです。

OpenGLではサーバが扱えるデータの種類は決まっています。基本は単精度の浮動小数点数ですが、その配列や付加的な属性が付いたものなどもあります。仕様書の6章以降は各オブジェクトについての詳細な説明が載っています。

### データフローモデル

OpenGLのデータの基本的な流れを超ざっくり説明します。これは仕様書の図3-1の"Block diagram of the GL pipeline."を見ると一撃です。

アプリケーションはまず、OpenGLに描画する頂点 (たとえば三角形を表示したいときの各頂点) を渡します。すると頂点シェーダがその頂点情報に移動や座標変換などの計算を施します。たとえばこれはモデルデータのローカルな座標から描画空間の座標空間に変換する、というような用途に使っていそうです (理解が怪しい)。その結果得られた頂点をこんどはテッセレーションシェーダ (テッセレーション制御シェーダとテッセレーション評価シェーダがあります) に送り、その頂点情報からあらたに頂点を増加させます (オプショナルなシェーダなのでこれをしなくてもよいです)。テッセレーションというのは充填のことですが、たとえば三角形を与えられたときにそれを細かい三角形に分割して埋めるような感じで、高精度なモデルを生成するのに使われているらしいです。つぎはジオメトリシェーダに頂点を送り、各頂点にプリミティブを置くなどをします。ビルボード (常にカメラのほうを向いている板ポリゴン) やポイントスプライト (ビルボードみたいなもの) はジオメトリシェーダを利用するようです。ジオメトリシェーダの結果得られる頂点情報は固定機能のラスタライザに送られ、フラグメント (ピクセルのことだが、画面に表示するものとは限らないためこの名前がついている) の列に変換されます。ラスタライズは、頂点データからラスタ画像に変換するプロセスとも言えます。ラスタライズされた画像はフラグメントシェーダに送られます。フラグメントシェーダはDirectXではピクセルシェーダと呼ばれ、アプリケーションから与えられたパラメータや別のラスタ画像等を参照しながら最終的なフラグメントを計算します。ぼかしなどのポストプロセスなどに用いられるようです。テクスチャマッピングもここで行われるものだったような気がします。

---

ぼくが話せるのはここまでだ！！

## おわりに

ざっと現状の理解を書き出してみました。一応すこしずつ進捗がだせていますよということと、さらっとさらっただけではわからなかったお気持ち的なことこと (データ転送プロトコルのこと、名前が似ちゃっているけど別物のデータたちのことなど) が腑に落ちるので仕様書読むのはいいぞ、ということを伝えたかった。ということにして今日はご勘弁ください。
